# 一、6大设计原则：

## 1.1  单一职责原则:

单一职责原则 (Single Responsibility Principle) SRP的定义： <font color =red>**应该有且仅有一个原因引起类的变更**。</font>

单一职责原则适用于接口、类，同样适用于方法，一个方法尽可能只做一件事情，但是该原则最难划分的就是**职责**。一般建议来看，接口的设计**一定**要做到单一职责，类的设计**尽量**做到只有一个原因引起变化。

## 1.2  里氏替换原则：

(Liskov Substitution Principle) LSP

4层含义：

	1. 子类必须完全实现父类的方法
	2. 子类可以有自己的个性
	3. 覆盖或者实现父类的方法时输入参数可以被**放大**
	4. 覆写或者实现父类的方法时输出结果可以被**缩小**

## 1.3 依赖倒置原则：

(Dependence Inversion Principle) DIP

3层含义：

	1. 高层模块不应该依赖底层模块，两者都应该依赖其抽象
	2. 抽象不应该依赖细节
	3. 细节应该依赖抽象

在java语言中，**抽象**就是指接口或者抽象类，两者时不能直接被实例化的。**细节**就是实现类，实现接口或者抽象类而产生的类就是细节。

依赖倒置原则在java中就是：  面向接口编程（OOD）

	1. 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的
	2. 接口或者抽象类不依赖于实现类
	3. 实现类依赖接口或抽象类

**采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。**

## 1.4 接口隔离原则：

建立单一的接口，不要建立臃肿庞大的接口。换句话说，就是**接口尽量细化，同时接口中的方法尽量少**。

<font color=red>接口隔离原则</font>和<font color=red>单一职责</font>的**区别**在于**两者的角度是不同的**，单一职责是从业务逻辑划分的角度去看待，要求类和接口的职责要单一。而接口隔离原则是要求接口的方法尽量少，尽量提供专用的接口，有几个模块就有几个接口。

## 1.5 迪米特法则：

(Law of Demeter,) LoD  

只与直接的朋友通信。朋友类的定义为：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。

## 1.6 开闭原则：



# 二、23种设计模式：

## 2.1 单例模式[Singleton Pattern]：

**定义：**某一个类只有一个实例，而且自行实例化并向整个系统提供该实例。

**特点：**

	1. 单例类只能有一个实例
	2. 单例类必须自己创建自己的实例类

**应用：**单例模式保证了全局对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。spring中对bean的管理默认都是单例模式，需要注意多线程使用的问题，避免对非静态变量使用不当导致数据不一致的情况发生，比如java中的日期类。

**注意：**多线程使用的时候，注意实例变量是否会因为多线程而产生状态不一致问题。

**实现：**  **饿汉式、懒汉式、枚举类**

## 2.2 工厂方法模式：

**定义：**定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

**优点：**

```
1. 良好的封装性，代码结构清晰，降低模块间的耦合性。
2. 可扩展性好，在增加新的产品类时，只需要添加新的子类，不用改动工厂类。
3. 高层模块只依赖产品的抽象，符合迪米特法则、依赖倒置原则和里氏替换原则。
```

**应用场景：**需要灵活、可扩展框架的时候，可以考虑采用工厂方法模式。

**扩展：**

```
1. 升级为多工厂模式，，对不同的产品定义不同的创造者
2. 替换单例模式， 采用反射的方式创建对象
3. 延迟初始化，用map容器保存生产的对象
```

## 2.3 抽象工厂模式：

**定义：** 为创建**一组**相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。

工厂方法模式提供了针对一类产品在创建时的低耦合的解决方案，抽象工厂模式是工厂方法模式的升级版，在有多个业务分类时，是非常好的解决方式。

**优点：**

```
1. 封装性，高层模块并不关心每个产品类是如何创建出来的，这是由具体的某一个工厂类关心的，高层模块只需要知道工厂类是谁就可以创建出需要的对象。
2. 产品内部的约束为非公开状态。
```

**缺点：**

```
1. 可扩展性不好，如果要增加一个新的产品，涉及到的改动很大。
```

## 2.4 模板方法模式：

**定义：**定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。**仅仅使用java的继承机制来实现。**

抽象模板的方法分为两类：

1. 基本方法：

   也叫基本操作，是由子类实现的方法，并且在模板方法中被调用。

2. 模板方法：

   可以有一个或者多个，一般有一个固定的实现逻辑，完成对基本方法的调用。

**注：**为了防止恶意操作，一般模板方法都加上final关键字，不允许被覆写。

**优点：**

```
1. 封装不变部分，扩展可变部分。
	不变部分由父类实现，可变部分通过继承由子类来扩展
2. 提取公共部分代码，便于维护。
3. 行为由父类控制，子类实现。
```

**缺点：**

```
高层模块并不是和具体实现完全解耦合。在模板方法中，子类的执行结果会影响父类的结果。
```

















































































































































